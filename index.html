<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Pronunciation Assessment</title>
  <style>
    /* ===== Global & Layout ===== */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: transparent;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      user-select: none;
    }

    /* iOS: Â≠ó‰Ωì+5%, Padding-30% */
    .ios-mode .bar-letter {
      font-size: clamp(14px, 3vw, 20px) !important;
    }

    .ios-mode .bar-ipa {
      font-size: clamp(13px, 2.3vw, 16px) !important;
    }

    .ios-mode .bar-group {
      padding-top: 11px !important;
    }

    /* PC: ÂÆΩÂ∫¶-30% */
    .pc-mode .bar-group {
      min-width: 18px !important;
      max-width: 37px !important;
      width: clamp(18px, 4vw, 37px) !important;
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 400px;
      overflow-y: auto;
    }

    /* ===== Buttons (V81 Capsule Layout) ===== */
    .playback-btn {
      flex: 1;
      height: 48px;
      background-color: #3A66B8;
      color: white;
      border: none;
      border-radius: 24px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      opacity: 0.9;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .playback-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .playback-btn:active {
      transform: scale(0.95);
      opacity: 0.7;
    }

    /* ===== Target Word & IPA ===== */
    #target-word {
      font-size: 28px;
      font-weight: 600;
      color: #3A66B8;
      text-align: center;
      margin-top: 20px;
      margin-bottom: 4px;
      display: none;
    }

    #target-ipa {
      display: none;
      font-size: 18px;
      color: #3A66B8;
      opacity: 0.8;
      margin-top: 4px;
      font-family: "Lucida Sans Unicode", "Arial Unicode MS", sans-serif;
    }

    .hint-btn {
      background: #3A66B8;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 6px 18px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 10px;
      box-shadow: 0 4px 8px rgba(58, 102, 184, 0.2);
    }

    /* ===== Total Score & Stars ===== */
    .score-header {
      text-align: center;
      margin-bottom: auto;
      transition: opacity 0.3s;
    }

    .total-score {
      font-size: 51px;
      font-weight: 500;
      color: #3A66B8;
      line-height: 1;
    }

    .score-unit {
      font-size: 19px;
      margin-left: 4px;
    }

    .stars {
      font-size: 22px;
      color: #3A66B8;
      margin-top: 12px;
      margin-bottom: 4px;
      letter-spacing: 4px;
    }

    .stars .gray {
      color: #e0e0e0;
    }

    /* ===== Phoneme Bars ===== */
    .bars-container {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }

    .bar-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 26px;
      max-width: 53px;
      width: clamp(26px, 5.3vw, 53px);
      flex-shrink: 1;
      background-color: #e1f5fe;
      border-top-left-radius: 18px;
      border-top-right-radius: 18px;
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
      padding-top: 16px;
      position: relative;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .bar-group:active {
      transform: scale(0.95);
    }

    .bar-letter {
      font-size: clamp(13px, 2.7vw, 19px);
      color: #3A66B8;
      margin-bottom: 4px;
      font-weight: 500;
      word-break: break-all;
    }

    .bar-ipa {
      font-size: clamp(12px, 2.1vw, 15px);
      color: #555;
      margin-bottom: 10px;
      font-family: "Lucida Sans Unicode", "Arial Unicode MS", sans-serif;
    }

    .bar-score {
      width: 100%;
      text-align: center;
      color: white;
      padding: 6px 0;
      font-size: 12px;
      font-weight: 600;
      border-radius: 4px;
      margin-top: auto;
    }

    .bg-good {
      background-color: #81c784;
    }

    .bg-fair {
      background-color: #ffb74d;
    }

    .bg-poor {
      background-color: #e57373;
    }

    /* ===== Bottom Controls ===== */
    .controls {
      padding: 0 20px 40px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: white;
      padding-bottom: max(50px, env(safe-area-inset-bottom));
      flex-shrink: 0;
      transform: translateY(0%);
    }

    .btn-row {
      display: flex;
      align-items: center;
      gap: 15px;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
    }

    #tip-box {
      width: 90%;
      background: #f1f8ff;
      padding: 8px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.8;
      color: #01579b;
      margin: 10px auto;
      border: 1px solid #3A66B8;
      text-align: center;
      display: none;
      box-shadow: 0 4px 12px rgba(58, 102, 184, 0.1);
    }

    .mic-button {
      flex: 1;
      height: 48px;
      border-radius: 24px;
      background-color: #3A66B8;
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 10px rgba(58, 102, 184, 0.4);
      cursor: pointer;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
      color: white;
      font-weight: bold;
      font-size: 16px;
      gap: 8px;
    }

    .mic-button svg {
      width: 20px;
      height: 20px;
      fill: white;
    }

    .mic-button.recording {
      background-color: #ff5252;
      box-shadow: 0 0 0 6px rgba(255, 82, 82, 0.3);
      animation: pulse 1.5s infinite;
    }

    .status-text {
      margin-top: 12px;
      color: #333;
      font-size: 15px;
      font-weight: 500;
      min-height: 20px;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }
  </style>
</head>

<body>
  <!-- Ê†∏ÂøÉÂ±ïÁ§∫ÂÆπÂô® -->
  <div class="container">
    <!-- Header Word & IPA -->
    <div id="target-word" style="font-size: 24px;">Ê±âËØëÂä†ËΩΩ‰∏≠...</div>
    <button id="web-hint-btn" class="hint-btn">ÊèêÁ§∫</button>
    <div id="target-ipa"></div>

    <!-- Score Header -->
    <div class="score-header" id="score-header" style="opacity: 0;">
      <div class="total-score" id="main-score">0<span class="score-unit">ÂàÜ</span></div>
      <div class="stars" id="stars">‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
    </div>

    <div id="tip-box"></div>

    <!-- Bars Area -->
    <div class="bars-container" id="bars-container">
      <div style="color:#666; font-size: 16px; margin: 20px; text-align: center; line-height: 1.6;">
        ËØ∑ÁÇπÂáª‰∏ãÊñπÈ∫¶ÂÖãÈ£éÂºÄÂßãÂΩïÈü≥
      </div>
    </div>
  </div>

  <!-- Bottom Controls -->
  <div class="controls" id="controls-section">
    <div class="btn-row" id="recording-controls">
      <!-- ÂõûÊîæÂèëÈü≥ÊåâÈíÆ (Â∑¶) -->
      <button id="playbackBtn" class="playback-btn" disabled>
        <span>üëÇ ÂõûÊîæ</span>
      </button>

      <!-- Ê†∏ÂøÉÂΩïÈü≥ÊåâÈíÆ (Âè≥) -->
      <button id="recordBtn" class="mic-button">
        <svg viewBox="0 0 24 24">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" />
          <path
            d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" />
        </svg>
        <span id="record-text">ÂΩïÈü≥</span>
      </button>
    </div>
    <div class="status-text" id="status">ÁÇπÂáªÂΩïÈü≥</div>
  </div>

  <script>
    // ===== index.html V87: ‰øÆÂ§çÁâà + È´òÁ∫ßÈü≥Á¥†ÂØπÈΩê =====

    function logDebug(msg) { console.log(msg); }

    let PhonemeTips = {};
    fetch("./phoneme_tips.js").then(r => r.text()).then(txt => {
      const match = txt.match(/PhonemeTips\s*=\s*({[\s\S]*});/);
      if (match) PhonemeTips = eval('(' + match[1] + ')');
      const extensions = {
        "l_light": "„ÄêÊ∏ÖÊô∞ l „ÄëÂá∫Áé∞Âú®ËØçÈ¶ñÊàñÂÖÉÈü≥Ââç„ÄÇ",
        "l_dark": "„ÄêÊöó l„ÄëÂá∫Áé∞Âú®ËØçÂ∞æÊàñËæÖÈü≥Âêé„ÄÇ",
        "r_initial": "„ÄêÂç∑Ëàå r „ÄëÂá∫Áé∞Âú®ËØçÈ¶ñÊàñÈáçËØª‰ΩçÁΩÆ„ÄÇ",
        "r_final": "„ÄêÂº±Âåñ r„ÄëÂá∫Áé∞Âú®ËØçÂ∞æÊàñÂÖÉÈü≥Âêé„ÄÇ"
      };
      PhonemeTips = { ...PhonemeTips, ...extensions };
    }).catch(e => console.error("Tips load failed", e));

    const params = new URLSearchParams(window.location.search);
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isAnkiPC = /QtWebEngine/i.test(navigator.userAgent);

    if (isIOS) document.body.classList.add("ios-mode");
    if (isAnkiPC) document.body.classList.add("pc-mode");
    document.body.classList.add("loaded");

    const targetWord = decodeURIComponent(params.get("word") || "Apple");
    const targetTrans = decodeURIComponent(params.get("trans") || params.get("translations") || targetWord);
    const userIpa = decodeURIComponent(params.get("phonetic") || params.get("USPhonetic") || params.get("usphonetic") || params.get("us") || params.get("ipa") || "");

    const wordDisplayEl = document.getElementById("target-word");
    const ipaDisplayEl = document.getElementById("target-ipa");
    const hintBtn = document.getElementById("web-hint-btn");

    if (wordDisplayEl) {
      wordDisplayEl.innerText = targetTrans;
      wordDisplayEl.style.display = "block";
    }
    if (hintBtn) {
      hintBtn.style.display = "inline-block";
      hintBtn.onclick = async () => {
        hintBtn.style.display = "none";
        if (ipaDisplayEl) {
          ipaDisplayEl.innerText = `/${userIpa.replace(/\//g, '')}/`;
          ipaDisplayEl.style.display = "block";
        }
      };
    }

    /* ===== State ===== */
    let recording = false;
    let audioContext = null;
    let recStream = null;
    let recProcessor = null;
    let recBuffer = [];
    let lastRecordedBlob = null;

    async function initAudioContext() {
      if (audioContext) {
        if (audioContext.state === 'suspended') await audioContext.resume();
        return;
      }
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        // V85: Âº∫Âà∂ 16000Hz ‰ª•ÂåπÈÖç Azure Ê®°ÂûãÔºå‰øÆÂ§ç 0 ÂàÜÈóÆÈ¢ò
        audioContext = new Ctx({ sampleRate: 16000 });
        console.log("AudioContext SampleRate:", audioContext.sampleRate);
      } catch (e) {
        console.error("Ctx init failed", e);
      }
    }

    const recordBtn = document.getElementById("recordBtn");
    const playbackBtn = document.getElementById("playbackBtn");
    const statusLabel = document.getElementById("status");

    /* ===== Render Logic with AI Alignment (V87 Port) ===== */
    const tipBox = document.getElementById("tip-box");

    /* ===== Mapping Engine (Ported from pro_eval V89) ===== */
    const ARPABET_TO_IPA = {
      "ae": "√¶", "ax": "…ô", "ah": " å", "aa": "…ë", "ao": "…î", "ih": "…™", "eh": "e", "iy": "i", "uh": " ä", "uw": "u",
      "er": "…úÀêr", "axr": "…ôr", "ey": "e…™", "ay": "a…™", "oy": "…î…™", "aw": "a ä", "ow": "o ä",
      "p": "p", "b": "b", "t": "t", "d": "d", "k": "k", "g": "g", "f": "f", "v": "v", "th": "Œ∏", "dh": "√∞",
      "s": "s", "z": "z", "sh": " É", "zh": " í", "ch": "t É", "jh": "d í", "m": "m", "n": "n", "ng": "≈ã", "l": "l", "r": "r", "w": "w", "y": "j", "hh": "h"
    };

    const VOWELS = ["ae", "ax", "ah", "aa", "ao", "ih", "eh", "iy", "uh", "uw", "er", "axr", "ey", "ay", "oy", "aw", "ow"];

    function getStandardIpa(pObj, index, allPhonemes) {
      if (!pObj) return { display: "", tts: "" };
      if (pObj.IPA) return { display: pObj.IPA, tts: pObj.IPA };
      const code = (pObj.Phoneme || "").toLowerCase();

      const phArr = allPhonemes || [];
      const idx = (index !== undefined) ? index : -1;
      const stdIpa = ARPABET_TO_IPA[code] || code;

      // Special l/r Handling
      if (code === "l") {
        const nextPh = (idx >= 0 && idx + 1 < phArr.length) ? phArr[idx + 1] : null;
        const isFollowedByVowel = nextPh && VOWELS.includes(nextPh.Phoneme.toLowerCase());
        return {
          display: "l",
          tts: (isFollowedByVowel || idx === 0) ? "l_light" : "l_dark"
        };
      }
      if (code === "r") {
        const prevPh = (idx >= 1) ? phArr[idx - 1] : null;
        const isPrecededByVowel = prevPh && VOWELS.includes(prevPh.Phoneme.toLowerCase());
        return {
          display: "r",
          tts: (isPrecededByVowel || idx === phArr.length - 1) ? "r_final" : "r_initial"
        };
      }

      // Critical V89 Fix: Return mapped IPA for TTS, not the raw Arpabet code
      return { display: stdIpa, tts: stdIpa };
    }

    /* ===== A.I. Alignment Engine (Ported from pro_eval V87) ===== */
    const DIGRAPHS = ["ai", "ay", "ea", "ee", "ei", "ey", "ie", "oa", "oe", "oi", "oo", "ou", "oy", "ui", "au", "aw", "ch", "sh", "th", "wh", "ph", "ng", "nk", "ck", "kn", "wr", "gh", "gu", "tr", "dr", "ts", "ds", "pp", "tt", "bb", "dd", "ff", "gg", "mm", "nn", "rr", "ss", "ll", "zz", "cc"];
    const TRIGRAPHS = ["ght", "tch", "dge", "iou"];

    function alignLettersToPhonemes(word, phonemes) {
      const letters = word.toLowerCase();
      const pCount = phonemes.length;
      let letterIndex = 0;
      const phObjects = phonemes.map((p, idx) => {
        const info = getStandardIpa(p, idx, phonemes);
        return { display: info.display, tts: info.tts, score: p.PronunciationAssessment?.AccuracyScore || 0, raw: p };
      });
      const finalGroups = [];

      for (let i = 0; i < pCount; i++) {
        let curr = phObjects[i];
        while (letterIndex < letters.length && !/[a-z]/.test(letters[letterIndex])) letterIndex++;
        let curChar = (letterIndex < letters.length) ? letters[letterIndex] : "";
        let groupLetters = curChar;
        let displayIpa = curr.display;
        let ttsIpa = curr.tts;
        let totalScore = curr.score;

        let nextPh = (i + 1 < pCount) ? phObjects[i + 1] : null;

        // 1. ÂêàÂπ∂ÈÄªËæë (ÁÆÄÂçïÂ§çÂàª pro_eval)
        // User Request V91: "le" pronounced as /…ôl/ should be /(…ô)l/
        // User Request V91: "al" should NOT be grouped (Removed potential al logic if any)
        if ((curChar === 'x' && (curr.display === 'k' || curr.display === 'g') && nextPh && (nextPh.display === 's' || nextPh.display === 'z')) ||
          (curChar === 'u' && curr.display === 'j' && nextPh && nextPh.display.includes('u')) ||
          (letters.endsWith('le') && letterIndex >= letters.length - 2 && curr.display === '…ô' && nextPh && nextPh.display === 'l')) {

          if (letters.endsWith('le') && curChar === 'l') { // Safety check for le
            displayIpa = "(…ô)l";
            ttsIpa += " " + nextPh.tts;
          } else {
            displayIpa += nextPh.display;
            ttsIpa += " " + nextPh.tts;
          }

          totalScore = (totalScore + nextPh.score) / 2;
          i++;
        }

        // 2. ÂàáÂùóÂ§ßÂ∞è
        let chunkSize = 1;
        if (letterIndex + 3 <= letters.length && TRIGRAPHS.includes(letters.substr(letterIndex, 3))) chunkSize = 3;
        else if (letterIndex + 2 <= letters.length && DIGRAPHS.includes(letters.substr(letterIndex, 2))) chunkSize = 2;

        groupLetters = word.substr(letterIndex, chunkSize);
        letterIndex += chunkSize;

        // 3. ÈùôÈü≥Â≠óÊØçÂê∏Êî∂ (ÁÆÄÂåñÁâà)
        while (letterIndex < letters.length) {
          let peek = letters[letterIndex];
          if (!/[a-z]/.test(peek)) { groupLetters += word[letterIndex]; letterIndex++; continue; }
          // ÁÆÄÂçïËßÑÂàôÔºöe ÁªìÂ∞æ‰∏îÊó†‰ªéÂ±ûÈü≥Á¥†
          if (peek === 'e' && i === pCount - 1) { groupLetters += peek; letterIndex++; }
          else break;
        }

        finalGroups.push({ letters: groupLetters, displayPh: displayIpa, ttsIpa: ttsIpa, score: totalScore });
      }
      if (letterIndex < letters.length) finalGroups[finalGroups.length - 1].letters += word.substr(letterIndex);
      return finalGroups;
    }

    async function playPhonemeTTS(ttsIpa) {
      try {
        const ssml = `<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><voice name="en-US-ChristopherNeural"><prosody volume="+30.00%"><phoneme alphabet="ipa" ph="${ttsIpa}"> phoneme </phoneme></prosody></voice></speak>`;
        const res = await fetch(window.location.origin + "/tts", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ssml })
        });
        if (res.ok) {
          const blob = await res.blob();
          const audio = new Audio(URL.createObjectURL(blob));
          audio.play();
        }
      } catch (e) { console.error("TTS Error", e); }
    }

    /* ===== TTS & Tips (Ported from pro_eval V88) ===== */
    window.playPhoneme = async (ttsIpa, displayPhoneme) => {
      // Logic: 1. Tip Key Extraction 2. Static Audio 3. TTS Fallback

      let tipKey = ttsIpa.split(' ')[0].trim();
      const cleanDisplay = displayPhoneme.replace(/[()]/g, '').trim();

      // Special handling for dark l
      if (displayPhoneme.includes("(…ô)l") || displayPhoneme === "…ôl") {
        tipKey = "l_dark";
      }

      console.log(`[AUDIO] Attempting Key: ${tipKey}, Display: ${cleanDisplay}`);

      // 1. Show Tip
      const tip = PhonemeTips[tipKey] || PhonemeTips[cleanDisplay] || PhonemeTips[cleanDisplay.split(' ')[0]];
      if (tip) {
        if (tipBox) {
          tipBox.style.display = "block";
          tipBox.innerText = `/${displayPhoneme}/ : ${tip}`;
        }
      }

      // 2. Play Static Audio
      const audioUrl = `/audio/phoneme/${tipKey}.mp3`;
      const audio = new Audio(audioUrl);

      audio.onerror = async () => {
        console.log(`‚ÑπÔ∏è Static audio ${tipKey}.mp3 not found, falling back to TTS`);
        // Fallback: Degrade IPA for Azure TTS (remove custom suffixes)
        const fallbackIpa = ttsIpa
          .replace(/l_(light|dark)/g, 'l')
          .replace(/r_(initial|final)/g, 'r');
        await playPhonemeTTS(fallbackIpa);
      };

      try {
        await audio.play();
      } catch (err) {
        console.error("Audio playback error", err);
      }
    }

    function renderResult(nbest) {
      if (!nbest || !nbest.Words || nbest.Words.length === 0) return;

      const barsContainer = document.getElementById("bars-container");
      barsContainer.innerHTML = "";

      const wordObj = nbest.Words[0];
      const mainScore = nbest.PronunciationAssessment ? nbest.PronunciationAssessment.AccuracyScore : 0;

      // Update Score Header
      const scoreHeader = document.getElementById("score-header");
      const mainScoreEl = document.getElementById("main-score");
      const starsEl = document.getElementById("stars");

      scoreHeader.style.opacity = 1;
      mainScoreEl.innerHTML = Math.round(mainScore) + '<span class="score-unit">ÂàÜ</span>';

      let stars = "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ";
      if (mainScore < 40) stars = "‚òÖ<span class='gray'>‚òÖ‚òÖ‚òÖ‚òÖ</span>";
      else if (mainScore < 60) stars = "‚òÖ‚òÖ<span class='gray'>‚òÖ‚òÖ‚òÖ</span>";
      else if (mainScore < 80) stars = "‚òÖ‚òÖ‚òÖ<span class='gray'>‚òÖ‚òÖ</span>";
      else if (mainScore < 90) stars = "‚òÖ‚òÖ‚òÖ‚òÖ<span class='gray'>‚òÖ</span>";

      starsEl.innerHTML = stars;

      // V87: Advanced Rendering with AI Alignment
      if (wordObj.Phonemes) {
        try {
          // V87: Ë∞ÉÁî®Ê†∏ÂøÉÂØπÈΩêÁÆóÊ≥ï
          const alignedData = alignLettersToPhonemes(targetWord, wordObj.Phonemes);

          alignedData.forEach(group => {
            const div = document.createElement("div");
            div.className = "bar-group";
            div.style.marginBottom = "10px";

            let s = group.score;
            let colorClass = s >= 80 ? "bg-good" : (s >= 60 ? "bg-fair" : "bg-poor");

            div.innerHTML = `
                   <div class="bar-letter">${group.letters}</div>
                   <div class="bar-ipa">/${group.displayPh}/</div>
                   <div class="bar-score ${colorClass}">${Math.round(s)}</div>
                `;
            div.onclick = () => playPhoneme(group.ttsIpa, group.displayPh);
            barsContainer.appendChild(div);
          });
        } catch (e) {
          console.error("Align Error", e);
          barsContainer.innerHTML = `<div style='color:red; font-size:12px'>Ê∏≤ÊüìÈîôËØØ: ${e.message}</div>`;
        }
      }
    }

    /* ===== Recording Logic (Independent) ===== */
    if (recordBtn) {
      recordBtn.onclick = async () => {
        if (!recording) {
          await startRecord();
        } else {
          stopRecord();
        }
      };
    }

    async function startRecord() {
      if (recording) return;

      try {
        await initAudioContext();
        if (!recStream) {
          recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        }

        const input = audioContext.createMediaStreamSource(recStream);
        recProcessor = audioContext.createScriptProcessor(4096, 1, 1);
        recBuffer = [];

        recProcessor.onaudioprocess = e => {
          if (recording) {
            recBuffer.push(new Float32Array(e.inputBuffer.getChannelData(0)));
          }
        };

        input.connect(recProcessor);
        recProcessor.connect(audioContext.destination);

        recording = true;
        recordBtn.classList.add("recording");
        statusLabel.innerText = "Ê≠£Âú®ÂΩïÂà∂... (ÁÇπÂáªÂÅúÊ≠¢)";

      } catch (e) {
        console.error("Mic error", e);
        alert("Êó†Ê≥ïÂêØÂä®ÂΩïÈü≥: " + e.message);
      }
    }

    function stopRecord() {
      if (!recording) return;
      recording = false;
      recordBtn.classList.remove("recording");
      statusLabel.innerText = "Ê≠£Âú®ËØÑÂàÜ...";

      if (recProcessor) recProcessor.disconnect();

      // V85 Fix: ÂΩªÂ∫ïÂÅúÊ≠¢È∫¶ÂÖãÈ£é
      if (recStream) {
        recStream.getTracks().forEach(t => t.stop());
        recStream = null;
      }

      // Merge & Encode
      const totalLen = recBuffer.reduce((acc, b) => acc + b.length, 0);
      const flatBuffer = new Float32Array(totalLen);
      let offset = 0;
      for (const b of recBuffer) {
        flatBuffer.set(b, offset);
        offset += b.length;
      }

      // V86: AudioContext Â∑≤Âº∫Âà∂ 16000Hz
      const wavBlob = encodeWAVFromFloat(flatBuffer);
      lastRecordedBlob = wavBlob;
      playbackBtn.disabled = false;

      sendCheck(wavBlob);
    }

    function encodeWAVFromFloat(samples) {
      const sampleRate = 16000; // Hardcoded matches Ctx
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + samples.length * 2, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, samples.length * 2, true);
      let off = 44;
      for (let i = 0; i < samples.length; i++, off += 2) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return new Blob([buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    async function sendCheck(blob) {
      try {
        const formData = new FormData();
        formData.append('audio', blob, 'speech.wav');
        formData.append('word', targetWord);

        const res = await fetch('/assess', { method: "POST", body: formData });
        const data = await res.json();
        if (data.success && data.nbest) {
          statusLabel.innerText = "ÊµãËØÑÂÆåÊàê";
          renderResult(data.nbest);

          // Android Bridge: Report Result
          const sessionId = params.get("session_id");
          if (sessionId) {
            const score = data.nbest.PronunciationAssessment.AccuracyScore;
            fetch("/api/report_result", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ session_id: sessionId, score: score })
            }).then(() => {
              logDebug("Session result reported");
              // Optional: Show feedback
              const st = document.getElementById("status");
              if (st) st.innerText += " (Â∑≤ÂêåÊ≠•)";
            }).catch(e => console.error("Report failed", e));
          }

        } else {
          statusLabel.innerText = "ÊµãËØÑÂ§±Ë¥•: " + (data.message || "Êú™Áü•ÂéüÂõ†");
        }
      } catch (e) {
        statusLabel.innerText = "ÁΩëÁªúÈîôËØØ";
      }
    }

    playbackBtn.onclick = async () => {
      if (lastRecordedBlob) {
        const reader = new FileReader();
        reader.onload = async (e) => {
          const audio = new Audio(e.target.result);
          try { await audio.play(); } catch (err) { alert("ÂõûÊîæÂ§±Ë¥•ÔºåËØ∑ÁÇπÂáªÈ°µÈù¢ÈáçËØï"); }
        };
        reader.readAsDataURL(lastRecordedBlob);
      }
    };
  </script>
</body>

</html>
