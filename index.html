<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>Anki Pronunciation</title>

<style>
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: transparent;
}

.card {
  padding: 12px;
}

#word {
  text-align: center;
  font-size: 26px;
  font-weight: 600;
  margin-bottom: 4px;
}

#ipa {
  text-align: center;
  font-size: 16px;
  color: #666;
  margin-bottom: 10px;
}

button {
  width: 100%;
  padding: 12px;
  font-size: 16px;
  border-radius: 10px;
  border: none;
  background: #1976ff;
  color: #fff;
}

button:active {
  background: #1258c7;
}

#status {
  text-align: center;
  font-size: 12px;
  color: #666;
  margin: 8px 0;
}

audio {
  width: 100%;
  margin-top: 6px;
  accent-color: #1976ff;
}

#scores {
  margin-top: 8px;
  font-size: 14px;
  line-height: 1.5;
  text-align: center;
}
</style>
</head>

<body>
<div class="card">

  <div id="word"></div>
  <div id="ipa"></div>

  <button id="recordBtn">ğŸ¤ å¼€å§‹å½•éŸ³</button>

  <div id="status">å‡†å¤‡å°±ç»ª</div>

  <audio id="player" controls></audio>

  <div id="scores"></div>

</div>

<script>
/* ===== è¯»å– Anki / URL å‚æ•° ===== */
const params = new URLSearchParams(window.location.search);
const word = params.get("word") || "example";
const ipa = params.get("ipa") || "";

document.getElementById("word").innerText = word;
document.getElementById("ipa").innerText = ipa;

/* ===== å½•éŸ³ç›¸å…³å˜é‡ ===== */
let audioContext = null;
let processor = null;
let input = null;
let stream = null;
let audioData = [];
let recording = false;

const recordBtn = document.getElementById("recordBtn");
const status = document.getElementById("status");
const player = document.getElementById("player");
const scoresDiv = document.getElementById("scores");

/* ===== ç‚¹å‡»å¼€å§‹ / åœæ­¢ ===== */
recordBtn.onclick = async () => {
  if (!recording) {
    await startRecording();
    recordBtn.innerText = "â¹ åœæ­¢å½•éŸ³";
    recording = true;
  } else {
    stopRecording();
    recordBtn.innerText = "ğŸ¤ å¼€å§‹å½•éŸ³";
    recording = false;
  }
};

/* ===== å¼€å§‹å½•éŸ³ï¼ˆSafari å¿…é¡» resumeï¼‰ ===== */
async function startRecording() {
  try {
    audioData = [];
    scoresDiv.innerHTML = "";

    audioContext = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 16000
    });

    // ğŸ”´ã€å…³é”®ã€‘iOS / Safari å¿…é¡»æ‰‹åŠ¨ resume
    if (audioContext.state === "suspended") {
      await audioContext.resume();
    }

    stream = await navigator.mediaDevices.getUserMedia({ audio: true });

    input = audioContext.createMediaStreamSource(stream);
    processor = audioContext.createScriptProcessor(4096, 1, 1);

    processor.onaudioprocess = e => {
      audioData.push(new Float32Array(e.inputBuffer.getChannelData(0)));
    };

    input.connect(processor);
    processor.connect(audioContext.destination);

    status.innerText = "å½•éŸ³ä¸­â€¦";

  } catch (err) {
    status.innerText = "æ— æ³•è®¿é—®éº¦å…‹é£";
    alert("æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨éº¦å…‹é£æƒé™");
    console.error(err);
  }
}

/* ===== åœæ­¢å½•éŸ³ ===== */
function stopRecording() {
  if (!audioContext) return;

  processor.disconnect();
  input.disconnect();
  stream.getTracks().forEach(t => t.stop());

  const wavBlob = encodeWAV(audioData, audioContext.sampleRate);
  player.src = URL.createObjectURL(wavBlob);

  status.innerText = "æµ‹è¯„ä¸­â€¦";
  sendToAzure(wavBlob);

  audioContext.close();
  audioContext = null;
}

/* ===== WAV ç¼–ç ï¼ˆ16k PCMï¼‰ ===== */
function encodeWAV(buffers, sampleRate) {
  let length = buffers.reduce((s, b) => s + b.length, 0);
  let pcm = new Int16Array(length);
  let offset = 0;

  buffers.forEach(b => {
    for (let i = 0; i < b.length; i++, offset++) {
      pcm[offset] = Math.max(-1, Math.min(1, b[i])) * 0x7fff;
    }
  });

  const buffer = new ArrayBuffer(44 + pcm.length * 2);
  const view = new DataView(buffer);

  function write(o, s) {
    for (let i = 0; i < s.length; i++) view.setUint8(o + i, s.charCodeAt(i));
  }

  write(0, "RIFF");
  view.setUint32(4, 36 + pcm.length * 2, true);
  write(8, "WAVE");
  write(12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  write(36, "data");
  view.setUint32(40, pcm.length * 2, true);

  let p = 44;
  pcm.forEach(v => {
    view.setInt16(p, v, true);
    p += 2;
  });

  return new Blob([view], { type: "audio/wav" });
}

/* ===== å‘é€åˆ° Render / Azure ===== */
async function sendToAzure(wavBlob) {
  try {
    const res = await fetch(
      "https://anki-pronunciation.onrender.com/assess?text=" +
        encodeURIComponent(word),
      { method: "POST", body: wavBlob }
    );

    const data = await res.json();
    const pa = data.NBest?.[0]?.PronunciationAssessment;

    if (!pa) {
      status.innerText = "æµ‹è¯„å¤±è´¥";
      return;
    }

    const acc = Math.round(pa.AccuracyScore || 0);
    const flu = Math.round(pa.FluencyScore || 0);
    const comp = Math.round(pa.CompletenessScore || 0);
    const total = Math.round((acc + flu + comp) / 3);

    status.innerText = "æµ‹è¯„å®Œæˆ";
    scoresDiv.innerHTML = `
      <strong>æ€»åˆ†ï¼š${total}</strong><br>
      å‡†ç¡®åº¦ï¼š${acc} ï½œ æµåˆ©åº¦ï¼š${flu} ï½œ å®Œæ•´åº¦ï¼š${comp}
    `;
  } catch (e) {
    status.innerText = "æµ‹è¯„å¤±è´¥";
    console.error(e);
  }
}
</script>
</body>
</html>